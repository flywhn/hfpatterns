# hfpatterns
learning patterns by head first

#策略模式 Strategy Pattern
定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

#工厂模式



#单例模式 Singleton Pattern
确保一个类只有一个实例，并提供全局访问点。

#观察者模式
定义了对象之间的一对多关系。当一个对象改变状态，其他依赖者都会收到通知。

当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。
but why?
关于观察者的一切，主题只知道观察者实现了某个接口（也就是Observer接口）。主题不需要
知道观察者的具体类是谁，做了些什么或其他任何细节。

任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西就是一个实现Observer接口的对象列表，
所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会收到任何影响。
同样的，也可以在任何时候删除某些观察者。

有新类型的观察者出现时，主题的代码不需要修改。假如我们有个新的具体类需要当观察者，我们不需要为了兼容新类型
而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，它只会发送通知
给所有实现了观察者接口的对象。

改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要它们之间的接口仍被遵守，我们就可以自由地改变它们。




#principles :

找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。

把会变化的部分取出并“封装”起来，好让其他部分不会受到影响。


针对接口编程，而不是针对实现编程。关键在于利用“多态”，实现动态绑定。
/*
	针对实现编程
	Dog d = new Dog();
	d.bark();
*/

// 针对接口/超类型编程

	Animal animal = new Dog();
	animal.makeSound();


多用组合，少用继承
